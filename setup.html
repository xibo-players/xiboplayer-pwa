<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google" content="notranslate">
  <title>Xibo Player Setup</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1D1D1D;
      color: #E0E0E0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: #2A2A2A;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      padding: 48px;
      max-width: 480px;
      width: 100%;
    }

    .logo {
      text-align: center;
      margin-bottom: 32px;
    }

    .logo-text {
      font-size: 36px;
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.5px;
    }

    .logo-text span {
      color: #0097D8;
    }

    .logo-sub {
      font-size: 14px;
      color: #888;
      margin-top: 4px;
    }

    /* Phases */
    .phase { display: none; }
    .phase.active { display: block; }

    /* Form styles */
    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #AAA;
      font-size: 13px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input {
      width: 100%;
      padding: 12px 14px;
      background: #1D1D1D;
      border: 2px solid #3A3A3A;
      border-radius: 8px;
      font-size: 15px;
      color: #E0E0E0;
      transition: border-color 0.2s;
    }

    input:focus {
      outline: none;
      border-color: #0097D8;
    }

    input::placeholder { color: #555; }

    button {
      width: 100%;
      padding: 14px;
      background: #0097D8;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }

    button:hover { background: #0084BE; }
    button:active { transform: scale(0.98); }
    button:disabled {
      background: #3A3A3A;
      color: #666;
      cursor: not-allowed;
      transform: none;
    }

    .error-msg {
      margin-top: 16px;
      padding: 12px 14px;
      background: rgba(244, 67, 54, 0.15);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: 8px;
      color: #EF9A9A;
      font-size: 14px;
      display: none;
    }

    /* Hardware key display */
    .hw-key {
      margin-top: 24px;
      padding: 12px 14px;
      background: #1D1D1D;
      border-radius: 8px;
      font-size: 12px;
      color: #666;
      text-align: center;
    }

    .hw-key code {
      color: #0097D8;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 13px;
      user-select: all;
    }

    /* Waiting phase */
    .waiting-card {
      text-align: center;
      padding: 16px 0;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid #3A3A3A;
      border-top-color: #0097D8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 24px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .waiting-title {
      font-size: 20px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 12px;
    }

    .waiting-desc {
      font-size: 14px;
      color: #888;
      line-height: 1.6;
      margin-bottom: 24px;
    }

    .waiting-desc strong {
      color: #E0E0E0;
    }

    .waiting-steps {
      text-align: left;
      padding: 16px 20px;
      background: #1D1D1D;
      border-radius: 8px;
      margin-bottom: 24px;
    }

    .waiting-steps li {
      list-style: none;
      padding: 6px 0;
      font-size: 14px;
      color: #AAA;
      position: relative;
      padding-left: 24px;
    }

    .waiting-steps li::before {
      content: '';
      position: absolute;
      left: 0;
      top: 12px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3A3A3A;
    }

    .waiting-steps li.done::before {
      background: #4CAF50;
    }

    .waiting-steps li.active::before {
      background: #0097D8;
      box-shadow: 0 0 8px rgba(0, 151, 216, 0.5);
    }

    .poll-status {
      font-size: 12px;
      color: #555;
      margin-top: 12px;
    }

    .poll-status .countdown {
      color: #0097D8;
    }

    .btn-secondary {
      background: transparent;
      border: 1px solid #3A3A3A;
      color: #AAA;
      margin-top: 8px;
    }

    .btn-secondary:hover { background: #333; }

    /* Success flash */
    .success-flash {
      position: fixed;
      inset: 0;
      background: rgba(0, 151, 216, 0.15);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .success-flash.active {
      display: flex;
      animation: flashIn 0.5s ease-out;
    }

    .success-check {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #4CAF50;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      color: white;
      animation: scaleIn 0.3s ease-out 0.1s both;
    }

    @keyframes flashIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes scaleIn { from { transform: scale(0); } to { transform: scale(1); } }

    /* Unlock gate */
    .unlock-title {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 8px;
      text-align: center;
    }

    .unlock-desc {
      font-size: 13px;
      color: #888;
      margin-bottom: 20px;
      text-align: center;
      line-height: 1.5;
    }

    /* Footer */
    .footer {
      margin-top: 24px;
      text-align: center;
      font-size: 12px;
      color: #444;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="logo">
      <div class="logo-text"><span>xibo</span> player</div>
      <div class="logo-sub">PWA Digital Signage</div>
    </div>

    <!-- Phase 0: Unlock gate (reconfiguration only) -->
    <div id="phase-unlock" class="phase">
      <div class="unlock-title">Reconfigure Display</div>
      <div class="unlock-desc">Enter the current CMS Key to change settings.</div>
      <form id="unlock-form">
        <div class="form-group">
          <label for="unlock-key">CMS Key</label>
          <input type="password" id="unlock-key" placeholder="Current CMS key" required>
        </div>
        <button type="submit">Unlock</button>
      </form>
      <div id="unlock-error" class="error-msg"></div>
    </div>

    <!-- Phase 1: Configuration Form -->
    <div id="phase-setup" class="phase active">
      <form id="setup-form">
        <div class="form-group">
          <label for="cms-url">CMS URL</label>
          <input type="url" id="cms-url" placeholder="https://cms.example.com" required>
        </div>

        <div class="form-group">
          <label for="cms-key">CMS Key</label>
          <input type="text" id="cms-key" placeholder="Your CMS secret key" required>
        </div>

        <div class="form-group">
          <label for="display-name">Display Name</label>
          <input type="text" id="display-name" placeholder="My Display" required>
        </div>

        <!-- Optional: Auto-authorize via CMS API -->
        <details id="api-details" style="margin-bottom: 16px;">
          <summary style="cursor: pointer; color: #0097D8; font-size: 13px; margin-bottom: 8px;">
            Auto-authorize via API (optional)
          </summary>
          <div class="form-group" style="margin-top: 8px;">
            <label for="api-client-id">API Client ID</label>
            <input type="text" id="api-client-id" placeholder="From CMS > Applications">
          </div>
          <div class="form-group">
            <label for="api-client-secret">API Client Secret</label>
            <input type="password" id="api-client-secret" placeholder="Application secret">
          </div>
          <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
            Create an Application in CMS &gt; Administration &gt; Applications with client_credentials grant.
            If provided, the display will be auto-authorized after registration.
          </div>
        </details>

        <button type="submit" id="submit-btn" disabled>Loading...</button>
        <button type="button" id="btn-back-player" class="btn-secondary" style="display: none;">Back to Player</button>
      </form>

      <div id="error" class="error-msg"></div>

      <div class="hw-key">
        Hardware Key: <code id="hw-key-display">...</code>
      </div>
    </div>

    <!-- Phase 2: Waiting for Authorization -->
    <div id="phase-waiting" class="phase">
      <div class="waiting-card">
        <div class="spinner"></div>
        <div class="waiting-title">Waiting for Authorization</div>
        <div class="waiting-desc">
          Display <strong id="waiting-display-name"></strong> has been registered.<br>
          Authorize it in your CMS to start playback.
        </div>

        <ul class="waiting-steps">
          <li class="done">Connected to CMS</li>
          <li class="done">Display registered</li>
          <li class="active">Awaiting authorization in CMS</li>
          <li>Start playback</li>
        </ul>

        <div class="hw-key">
          Hardware Key: <code id="hw-key-waiting">...</code>
        </div>

        <div class="poll-status">
          Checking again in <span class="countdown" id="countdown">15</span>s...
        </div>

        <button id="btn-back" class="btn-secondary">Back to Settings</button>
      </div>
    </div>

    <div class="footer" id="version-footer">
      Xibo Player
    </div>
  </div>

  <!-- Success Flash Overlay -->
  <div id="success-flash" class="success-flash">
    <div class="success-check">&#10003;</div>
  </div>

  <script type="module">
    import { config, CmsApiClient } from '@xiboplayer/utils';
    import { RestClient, XmdsClient } from '@xiboplayer/xmds';

    // Inject version from Vite build
    const appVersion = typeof __APP_VERSION__ !== 'undefined' ? __APP_VERSION__ : '?';
    document.getElementById('version-footer').textContent = `Xibo Player v${appVersion}`;

    // ── Elements ──
    const form = document.getElementById('setup-form');
    const errorEl = document.getElementById('error');
    const submitBtn = document.getElementById('submit-btn');
    const phaseUnlock = document.getElementById('phase-unlock');
    const phaseSetup = document.getElementById('phase-setup');
    const phaseWaiting = document.getElementById('phase-waiting');
    const countdownEl = document.getElementById('countdown');
    const waitingNameEl = document.getElementById('waiting-display-name');
    const btnBack = document.getElementById('btn-back');
    const successFlash = document.getElementById('success-flash');

    // Show hardware key
    const hwKey = config.hardwareKey;
    document.getElementById('hw-key-display').textContent = hwKey;
    document.getElementById('hw-key-waiting').textContent = hwKey;

    // ── State ──
    let pollTimer = null;
    let countdownTimer = null;
    let pollSeconds = 15;

    // ── Transport: try REST first, fall back to SOAP ──
    let transport = null;
    async function getTransport() {
      if (transport) return transport;
      try {
        const rest = new RestClient(config);
        await rest.registerDisplay();
        console.log('[Setup] Using REST transport');
        transport = rest;
      } catch (e) {
        console.log('[Setup] REST unavailable, using XMDS/SOAP:', e.message);
        transport = new XmdsClient(config);
      }
      return transport;
    }

    // ── Helpers ──
    function showPhase(phase) {
      phaseUnlock.classList.remove('active');
      phaseSetup.classList.remove('active');
      phaseWaiting.classList.remove('active');
      phase.classList.add('active');
    }

    function showError(msg) {
      errorEl.textContent = msg;
      errorEl.style.display = 'block';
    }

    function hideError() {
      errorEl.style.display = 'none';
    }

    function startCountdown() {
      let remaining = pollSeconds;
      countdownEl.textContent = remaining;
      clearInterval(countdownTimer);
      countdownTimer = setInterval(() => {
        remaining--;
        countdownEl.textContent = Math.max(0, remaining);
        if (remaining <= 0) clearInterval(countdownTimer);
      }, 1000);
    }

    function showSuccess() {
      successFlash.classList.add('active');
      setTimeout(() => {
        window.location.href = './index.html';
      }, 800);
    }

    // ── Authorization Polling ──
    async function checkAuthorization() {
      try {
        const client = await getTransport();
        const result = await client.registerDisplay();
        console.log('[Setup] Poll result:', result.code, result.message);

        if (result.code === 'READY') {
          // Authorized!
          clearInterval(pollTimer);
          clearInterval(countdownTimer);
          showSuccess();
          return;
        }

        // Still waiting — restart countdown
        startCountdown();
      } catch (error) {
        console.warn('[Setup] Poll failed:', error.message);
        startCountdown();
      }
    }

    function startPolling(displayName) {
      waitingNameEl.textContent = displayName;
      showPhase(phaseWaiting);
      startCountdown();
      pollTimer = setInterval(checkAuthorization, pollSeconds * 1000);
    }

    function stopPolling() {
      clearInterval(pollTimer);
      clearInterval(countdownTimer);
      pollTimer = null;
    }

    // ── Auto-authorize via CMS API ──
    async function tryAutoAuthorize(cmsUrl, hardwareKey) {
      const clientId = document.getElementById('api-client-id').value.trim();
      const clientSecret = document.getElementById('api-client-secret').value.trim();
      if (!clientId || !clientSecret) return false;

      try {
        const api = new CmsApiClient({ baseUrl: cmsUrl, clientId, clientSecret });
        await api.authenticate();

        const display = await api.findDisplay(hardwareKey);
        if (!display) {
          console.log('[Setup] Display not found via API (may not be registered yet)');
          return false;
        }

        if (display.licensed === 1) {
          console.log('[Setup] Display already authorized');
          return true;
        }

        // Auto-authorize
        await api.authorizeDisplay(display.displayId);
        console.log('[Setup] Display auto-authorized via API!');

        // Save API credentials for future use
        config.apiClientId = clientId;
        config.apiClientSecret = clientSecret;

        return true;
      } catch (error) {
        console.warn('[Setup] Auto-authorize failed:', error.message);
        return false;
      }
    }

    // ── Unlock gate for reconfiguration ──
    const isReconfigure = config.isConfigured() && config.cmsKey;
    const alreadyUnlocked = new URLSearchParams(window.location.search).has('unlocked');
    const btnBackPlayer = document.getElementById('btn-back-player');
    if (isReconfigure && !alreadyUnlocked) {
      // Show unlock phase instead of setup form
      showPhase(phaseUnlock);
    }
    if (isReconfigure || alreadyUnlocked) {
      // Show "Back to Player" on the setup form
      btnBackPlayer.style.display = 'block';
      // Pre-fill form with existing config
      document.getElementById('cms-url').value = config.cmsUrl;
      document.getElementById('cms-key').value = config.cmsKey;
      document.getElementById('display-name').value = config.displayName;
      if (config.apiClientId) {
        document.getElementById('api-client-id').value = config.apiClientId;
        document.getElementById('api-client-secret').value = config.apiClientSecret || '';
      }
    }

    // ── Back to Player (cancel reconfiguration) ──
    function goBackToPlayer() {
      stopPolling();
      window.location.href = './index.html';
    }
    btnBackPlayer.addEventListener('click', goBackToPlayer);

    // Esc also goes back to player when reconfiguring
    if (isReconfigure || alreadyUnlocked) {
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          goBackToPlayer();
        }
      });
    }

    // ── Unlock form handler ──
    document.getElementById('unlock-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const unlockError = document.getElementById('unlock-error');
      const enteredKey = document.getElementById('unlock-key').value.trim();

      if (enteredKey === config.cmsKey) {
        unlockError.style.display = 'none';
        // Pre-fill form with existing config
        document.getElementById('cms-url').value = config.cmsUrl;
        document.getElementById('cms-key').value = config.cmsKey;
        document.getElementById('display-name').value = config.displayName;
        if (config.apiClientId) {
          document.getElementById('api-client-id').value = config.apiClientId;
          document.getElementById('api-client-secret').value = config.apiClientSecret || '';
        }
        showPhase(phaseSetup);
      } else {
        unlockError.textContent = 'Incorrect CMS key';
        unlockError.style.display = 'block';
      }
    });

    // ── Pre-fill if first-time setup (no unlock gate) ──
    if (!isReconfigure && config.isConfigured()) {
      document.getElementById('cms-url').value = config.cmsUrl;
      document.getElementById('cms-key').value = config.cmsKey;
      document.getElementById('display-name').value = config.displayName;
      if (config.apiClientId) {
        document.getElementById('api-client-id').value = config.apiClientId;
        document.getElementById('api-client-secret').value = config.apiClientSecret || '';
      }
    }

    // ── Form Submit ──
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      hideError();

      const cmsUrl = document.getElementById('cms-url').value.trim().replace(/\/$/, '');
      const cmsKey = document.getElementById('cms-key').value.trim();
      const displayName = document.getElementById('display-name').value.trim();

      // Save config
      config.cmsUrl = cmsUrl;
      config.cmsKey = cmsKey;
      config.displayName = displayName;

      // Also backup hardware key to IndexedDB for stability
      backupHardwareKey(config.hardwareKey);

      // Test connection
      try {
        submitBtn.textContent = 'Connecting...';
        submitBtn.disabled = true;

        // Try REST first, fall back to SOAP
        transport = null; // reset transport for fresh detection
        const client = await getTransport();
        const result = await client.registerDisplay();

        if (result.code === 'READY') {
          showSuccess();
        } else {
          // Try auto-authorize via CMS API if credentials provided
          submitBtn.textContent = 'Authorizing...';
          const autoAuthed = await tryAutoAuthorize(cmsUrl, hwKey);

          if (autoAuthed) {
            // Verify registration
            const recheck = await client.registerDisplay();
            if (recheck.code === 'READY') {
              showSuccess();
              return;
            }
          }

          // Not authorized yet — switch to polling phase
          startPolling(displayName);
        }
      } catch (error) {
        showError(`Connection failed: ${error.message}`);
        submitBtn.textContent = 'Connect';
        submitBtn.disabled = false;
      }
    });

    // ── Back button ──
    btnBack.addEventListener('click', () => {
      stopPolling();
      showPhase(phaseSetup);
      submitBtn.textContent = 'Connect';
      submitBtn.disabled = false;
    });

    // ── IndexedDB hardware key backup ──
    async function backupHardwareKey(key) {
      try {
        const req = indexedDB.open('xibo-hw-backup', 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains('keys')) {
            db.createObjectStore('keys');
          }
        };
        req.onsuccess = () => {
          const db = req.result;
          const tx = db.transaction('keys', 'readwrite');
          tx.objectStore('keys').put(key, 'hardwareKey');
          tx.oncomplete = () => db.close();
        };
      } catch (e) {
        console.warn('[Setup] IndexedDB backup failed:', e);
      }
    }

    // ── Enable submit ──
    submitBtn.disabled = false;
    submitBtn.textContent = 'Connect';

    // ── Auto-resume polling if already registered but not authorized ──
    // Skip auto-resume when reconfiguring (user explicitly opened setup)
    if (config.isConfigured() && !isReconfigure) {
      (async () => {
        try {
          const client = await getTransport();
          const result = await client.registerDisplay();
          if (result.code === 'READY') {
            window.location.href = './index.html';
          } else {
            // Not authorized — go straight to polling
            startPolling(config.displayName);
          }
        } catch (e) {
          // Connection failed, show form
          console.log('[Setup] Auto-check failed, showing form');
        }
      })();
    }
  </script>
</body>
</html>
